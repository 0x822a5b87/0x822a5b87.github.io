---
title: 一个学习汇编的小游戏：BOX-256
date: 2025-03-18 14:58:57
tags:
  - assembly
  - OS
---

# BOX-256

## 前言

最近在学习 [RISC-V](https://drive.google.com/file/d/1uviu1nH-tScFfgrovvFCrj7Omv8tFtkp/view)，但是指令太多，并且学习起来确实很无聊，所以找到了这个小游戏来学习一下汇编的思路。虽然不是真正的标准 RISC-V，但是可以作为学习路上的一个参考工具，下面是 [BOX-256](http://box-256.com/) 的一些描述：

> BOX-256 is a 8-bit fantasy computer, with 256 bytes of memory, 16 color 16x16 display. It is also a programming game, where the player tries to pass the graphics tests and optimize the code to perfection. The ultimate goal is to use as few CPU cycles or lines of code as possible, by employing multithreading and other optimization tricks.

此外，文档里提到了一些比较重要的细节这里也稍微列举一下：

### **Program Counter**

> When the execution starts, the last memory slot (FF) is used as a program counter (PC). If a second thread is started, the additional PC will be in FE, the third will be in FD and so on. Since there is no memory protection, it is possible to write into PC directly and cause execution to jump. The behaviour is identical to using JMP instruction.

这里有一个点比较容易误解的是：`FF`, `FE`, 这些地址。我们前面提到BOX-256 -- **...with 256 bytes of memory...**。所以，其实我们的 `FF`，`FE` 就是我们在内存从后往前的索引。也就是说，当我们执行一个多线程的程序时，他的 PC 分别存放在内存的倒数第一个字节，倒数第二个字节，依次类推。

### **Multithreading**

> Because of cached reads, it is generally not possible for one thread to communicate with other thread simultaneously. HOWEVER two exceptions remains: An earlier thread can write to memory address later executed by later thread. So self-modifying code is possible. An earlier thread can also write to program counter (PC) owned by a later thread to cause an immediate jump.

### **Memory Addressing**

```
0 = Constant value
@ = Address in memory
* = Address pointed by another address (a.k.a pointer)
```

Examples:

```
Address: 00 01 02 03 04 05 06 07 08 09 0A 0B ...
Value:   00 1A 22 2A 5B 23 4A 28 00 03 BB CA ...

009 evaluates to 09
@09 evaluates to 03
*09 evaluates to 2A
```

### Instructions

|   INSTRUCTION    |                          DESCIPTION                          |
| :--------------: | :----------------------------------------------------------: |
| MOVE `A` `B` `C` |               Sets the value A into address B                |
|     JMP `A`      |                  Jumps the execution into A                  |
|   PIX `A` `B`    |        Outputs a pixel into index `A` with color `B`         |
| JEQ `A` `B` `C`  |        If `A` equals `B`, the execution jumps to `C`         |
| JNQ `A` `B` `C`  |      If `A` not equals `B`, the execution jumps to `C`       |
| JGR `A` `B` `C`  |    If `A` is greater than `B`, the execution jumps to `C`    |
| FLP `A` `B` `C`  | Flips the values between memory address `A` and memory address `B`. |
|     THR `A`      |         Starts a new thread from memory address `A`          |
| ADD `A` `B` `C`  | Adds values `A` and `B` together and stores the result in `C` |
| SUB `A` `B` `C`  |     Subtracts `B` from `A` and stores the result in `C`      |
| MUL `A` `B` `C`  | Multiplies values `A` and `B` and stores the results in `C`  |
| DIV `A` `B` `C`  |      Division `A` with `B` and stores the result in `C`      |
| MOD `A` `B` `C`  |    Take modulo of `A` and `B` and place the result in `C`    |

#### Instruction Examples

```assembly
FLP @10 @20 004 // Flip four (4) values between memory spaces starting from @10 and @20
```

1. Takes 4 values from memory that starts from address `10`;
2. Takes 4 values from memory that starts from address `20`;
3. Flips the values:
   1. Flips the values between memory address `10` and memory address `20`;
   2. Flips the values between memory address `11` and memory address `21`;
   3. ...

```assembly
JGR 020 @30 -04 // if value in @30 is smaller or equal to 20, jump forward 4 steps (16 bytes).
```

Note that you can prefix the C with minus '-' to get negative values.

### Opcodes

> Most of the opcodes are permutations of the same instruction. For example the ADD instruction has 8 different opcodes, depending on the 'memory depth' of the parameters.

| OPCODE | Instruction | P1   | P2   | P3   | Example         |
| :----: | ----------- | ---- | ---- | ---- | --------------- |
|   13   | ADD         | @    | 0    | @    | ADD @01 002 @03 |
|   14   | ADD         | *    | 0    | @    | ADD *01 002 @03 |
|   15   | ADD         | @    | @    | @    | ADD @01 @02 @03 |
|   16   | ADD         | *    | @    | @    | ADD *01 @02 @03 |
|   17   | ADD         | @    | *    | @    | ADD @01 *02 @03 |
|   18   | ADD         | *    | 0    | *    | ADD *01 002 *03 |
|   19   | ADD         | @    | 0    | *    | ADD @01 002 *03 |
|   1A   | ADD         | *    | @    | *    | ADD *01 @02 *03 |
|   1B   | ADD         | @    | @    | *    | ADD @01 @02 *03 |
|   1C   | ADD         | *    | *    | *    | ADD *01 *02 *03 |

## Level

### BIG SQUARE

![BIG SQUARE](/images/20250319/BIG-SQUARE.png)

#### code

> 这一题是游戏给出的示例，相对来说难度并不大。

```assembly
MOV 022 @80 000		// set @80 as Constant Value 22
MOV 030 @C0 000		// set @C0 as Constant Value 30
PIX @80 001 000		// draw a pixel with a fixed colour at the memory address @80
ADD @80 *C0 @80		// add values @80 and *C0 and stores the result in @80 
ADD @81 001 @81
JGR 00B @81 -0C
MOV 000 @81 000
ADD @C0 001 @C0
JMP @08 000 000
000 000 000 000
000 000 000 000
000 000 000 000
001 010 -01 -10
000 000 000 000
000 000 000 000
000 000 000 000
```

#### ADD @80 *C0 @80

`ADD @80 *C0 @80` 这里我们对 `@80` 和 `*C0` 进行求和，并将求和的结果存入 `@80`，初看这条命令其实会让人有一些疑惑，因为这里用到了 `*C0`，而 `*C0` 在前面的指令 `MOV 030 @C0 000` 中，指向了一个 **constant value** `30`。

这里，其实我们是在初始化内存的时候，将内存地址的一部分存放了我们需要的操作数，例如：

- `@30` == 001
- `@31` == 010
- `@32` == -01
- `@33` == -10

所以，当我们在调用指令 `ADD @80 *C0 @80` 时，其实相当于是 `num = num + 1;` 这条语句。

正如我们在很多地方会提到的，可执行程序会包含所谓的 `.data` 和 `.text`，这里的 `[@30, @33]` 这个区间就可以认为是我们的 `.data`，而 `[@00, @23]` 这个区域，则可以认为是我们的 `.text`
