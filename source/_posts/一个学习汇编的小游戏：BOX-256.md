---
title: 一个学习汇编的小游戏：BOX-256
date: 2025-03-18 14:58:57
tags:
  - assembly
  - OS
---

# BOX-256

## 前言

最近在学习 [RISC-V](https://drive.google.com/file/d/1uviu1nH-tScFfgrovvFCrj7Omv8tFtkp/view)，但是指令太多，并且学习起来确实很无聊，所以找到了这个小游戏来学习一下汇编的思路。虽然不是真正的标准 RISC-V，但是可以作为学习路上的一个参考工具，下面是 [BOX-256](http://box-256.com/) 的一些描述：

> BOX-256 is a 8-bit fantasy computer, with 256 bytes of memory, 16 color 16x16 display. It is also a programming game, where the player tries to pass the graphics tests and optimize the code to perfection. The ultimate goal is to use as few CPU cycles or lines of code as possible, by employing multithreading and other optimization tricks.

此外，文档里提到了一些比较重要的细节这里也稍微列举一下：

### **Program Counter**

> When the execution starts, the last memory slot (FF) is used as a program counter (PC). If a second thread is started, the additional PC will be in FE, the third will be in FD and so on. Since there is no memory protection, it is possible to write into PC directly and cause execution to jump. The behaviour is identical to using JMP instruction.

这里有一个点比较容易误解的是：`FF`, `FE`, 这些地址。我们前面提到BOX-256 -- **...with 256 bytes of memory...**。所以，其实我们的 `FF`，`FE` 就是我们在内存从后往前的索引。也就是说，当我们执行一个多线程的程序时，他的 PC 分别存放在内存的倒数第一个字节，倒数第二个字节，依次类推。

### **Multithreading**

> Because of cached reads, it is generally not possible for one thread to communicate with other thread simultaneously. HOWEVER two exceptions remains: An earlier thread can write to memory address later executed by later thread. So self-modifying code is possible. An earlier thread can also write to program counter (PC) owned by a later thread to cause an immediate jump.

### **Memory Addressing**

```
0 = Constant value
@ = Address in memory
* = Address pointed by another address (a.k.a pointer)
```

Examples:

```
Address: 00 01 02 03 04 05 06 07 08 09 0A 0B ...
Value:   00 1A 22 2A 5B 23 4A 28 00 03 BB CA ...

009 evaluates to 09
@09 evaluates to 03
*09 evaluates to 2A
```

### Instructions

|   INSTRUCTION    |                          DESCIPTION                          |
| :--------------: | :----------------------------------------------------------: |
| MOVE `A` `B` `C` |               Sets the value A into address B                |
|     JMP `A`      |                  Jumps the execution into A                  |
|   PIX `A` `B`    |        Outputs a pixel into index `A` with color `B`         |
| JEQ `A` `B` `C`  |        If `A` equals `B`, the execution jumps to `C`         |
| JNQ `A` `B` `C`  |      If `A` not equals `B`, the execution jumps to `C`       |
| JGR `A` `B` `C`  |    If `A` is greater than `B`, the execution jumps to `C`    |
| FLP `A` `B` `C`  | Flips the values between memory address `A` and memory address `B`. |
|     THR `A`      |         Starts a new thread from memory address `A`          |
| ADD `A` `B` `C`  | Adds values `A` and `B` together and stores the result in `C` |
| SUB `A` `B` `C`  |     Subtracts `B` from `A` and stores the result in `C`      |
| MUL `A` `B` `C`  | Multiplies values `A` and `B` and stores the results in `C`  |
| DIV `A` `B` `C`  |      Division `A` with `B` and stores the result in `C`      |
| MOD `A` `B` `C`  |    Take modulo of `A` and `B` and place the result in `C`    |

#### Instruction Examples

```assembly
FLP @10 @20 004 // Flip four (4) values between memory spaces starting from @10 and @20
```

1. Takes 4 values from memory that starts from address `10`;
2. Takes 4 values from memory that starts from address `20`;
3. Flips the values:
   1. Flips the values between memory address `10` and memory address `20`;
   2. Flips the values between memory address `11` and memory address `21`;
   3. ...

```assembly
JGR 020 @30 -04 // if value in @30 is smaller or equal to 20, jump forward 4 steps (16 bytes).
```

Note that you can prefix the C with minus '-' to get negative values.

### Opcodes

> Most of the opcodes are permutations of the same instruction. For example the ADD instruction has 8 different opcodes, depending on the 'memory depth' of the parameters.

| OPCODE | Instruction | P1   | P2   | P3   | Example         |
| :----: | ----------- | ---- | ---- | ---- | --------------- |
|   13   | ADD         | @    | 0    | @    | ADD @01 002 @03 |
|   14   | ADD         | *    | 0    | @    | ADD *01 002 @03 |
|   15   | ADD         | @    | @    | @    | ADD @01 @02 @03 |
|   16   | ADD         | *    | @    | @    | ADD *01 @02 @03 |
|   17   | ADD         | @    | *    | @    | ADD @01 *02 @03 |
|   18   | ADD         | *    | 0    | *    | ADD *01 002 *03 |
|   19   | ADD         | @    | 0    | *    | ADD @01 002 *03 |
|   1A   | ADD         | *    | @    | *    | ADD *01 @02 *03 |
|   1B   | ADD         | @    | @    | *    | ADD @01 @02 *03 |
|   1C   | ADD         | *    | *    | *    | ADD *01 *02 *03 |

## Level

### BIG SQUARE

![BIG SQUARE](/images/20250319/BIG-SQUARE.png)

#### Code

> 这一题是游戏给出的示例，相对来说难度并不大，整体的思路就是：我们在内存的 `@30`, `@31`, `@32`, `@33` 定义四个常量，分别是 `1`, `10`, `-1`, `-10`。而这个常量则是我们在循环的过程中控制像素点指针移动的变量。
>
> - 1 表示向右移动
> - 10 表示向下移动
> - -1 表示向左移动
> - -10 表示向上移动

```assembly
MOV 022 @80 000		// set the starting pixel index for the graph we are about to draw
MOV 030 @C0 000		// set a pointer with a constant value of 30, to which the offset's constant value in the loop.

# Here is where the loop start
PIX @80 001 000		// draw a pixel with a fixed colour
ADD @80 *C0 @80		// move the horizontal pixel index
ADD @81 001 @81		// store the total movements count
JGR 00B @81 -0C		// jump back if it's not done
MOV 000 @81 000		// reset the movements count
ADD @C0 001 @C0		// move the offset value in the loop
JMP @08 000 000		// return to the begining of the loop

# ...

# Here is where the .data section begins
001 010 -01 -10
000 000 000 000
000 000 000 000
000 000 000 000
```

#### ADD @80 *C0 @80

`ADD @80 *C0 @80` 这里我们对 `@80` 和 `*C0` 进行求和，并将求和的结果存入 `@80`，初看这条命令其实会让人有一些疑惑，因为这里用到了 `*C0`，而 `*C0` 在前面的指令 `MOV 030 @C0 000` 中，指向了一个 **constant value** `30`。

这里，其实我们是在初始化内存的时候，将内存地址的一部分存放了我们需要的操作数，例如：

- `@30` == 001
- `@31` == 010
- `@32` == -01
- `@33` == -10

所以，当我们在调用指令 `ADD @80 *C0 @80` 时，其实相当于是 `num = num + 1;` 这条语句。

正如我们在很多地方会提到的，可执行程序会包含所谓的 `.data` 和 `.text`，这里的 `[@30, @33]` 这个区间就可以认为是我们的 `.data`，而 `[@00, @23]` 这个区域，则可以认为是我们的 `.text`, 而 `[@80, ..)` 这个区间，则是我们的堆栈区间。

#### 一个更直观的图示

在绘制这个简单的**BIG SQUARE**的过程中，我们其实把他拆分为了绘制四条边，每条边包含了11个像素点。然后通过 `*C0` 指向的一个constant value来控制我们像素点的移动。如果我们修改一下我们的源码，我们可以非常清楚的看到我们像素点的绘制流程：

```assembly
MOV 022 @80 000
MOV 038 @C0 000
MOV 001 @82 000		// 我们在这里，使用了一个变量来作为 PIX 的参数

PIX @80 @82 000
ADD @80 *C0 @80
ADD @81 001 @81
JGR 00B @81 -0C
MOV 000 @81 000
ADD @C0 001 @C0
ADD @82 001 @82		// 当我们画完一条边的时候，我们修改 PIX 参数的值，也就是像素点的颜色
JMP @0C 000 000
000 000 000 000
000 000 000 000
000 000 000 000
001 010 -01 -10
000 000 000 000
```

这样我们最后得到的图像结果如下：

![BIG SQUARE NEW](/images/20250319/BIG-SQUARE-NEW.png)

### BIG SQUARE II

#### Code

第二题是画两个正方形，我们的思路是一样的：将一个正方形拆解为四条边，每次画一条边，并通过一个常量值来控制像素点的上下左右移动。区别在于，这次我们需要一个个额外的变量：**the total count of pixels per line**，这个变量用于控制我们循环输出时每条边包含的像素点数量；具体的代码实现如下：

```assembly
# .text
MOV 011 @80 000
MOV 03C @C0 000
MOV 00D @82 000		// 初始化每条边的长度，这里其实可以省略，因为我通过对点的重复着色，可以避免去进行长度调整
PIX @80 002 000
ADD @80 *C0 @80
ADD @81 001 @81
JGR @82 @81 -0C
MOV 000 @81 000
ADD @C0 001 @C0
ADD @80 *C0 @80
ADD @C0 001 @C0
JMP @0C 000 000
000 000 000 000
000 000 000 000
000 000 000 000

# .data
# 保存了变量，其中 001, 010, -01, -10 基本是用于控制光标上下左右移动
# 其余的变量是在画完一条边之后，将pixel移动到我们要绘制的直线的起点
001 000 010 000
-01 000 -10 011
001 -02 010 -20
-01 002 -10 000
000 000 000 000
```

#### Outputs

![BIG-SQUARE-II](/images/20250319/BIG-SQUARE-II.png)

### CHECKBOARD

> 这个问题也不难，思路就是使用FLP指令翻转色彩，但是需要注意的是，我们需要记录移动的次数，因为在换行时我们需要额外翻转一次。

#### Code

```assembly
# @80 = first color
# @81 = second color
# @82 = pixel index
# @83 = loop count

MOV 002 @80 000
MOV 003 @81 000
MOV 000 @82 000
MOV 000 @83 000
PIX @82 @80 000
FLP @80 @81 000
ADD @82 001 @82
ADD @83 001 @83
JGR @83 00F 008
JMP -14 000 000
FLP @80 @81 000
MOV 000 @83 000
JMP -20 000 000
```

#### Result

![CHECKBOARD](/images/20250319/CHECKBOARD.png)

### CHECKBOARD II

> 同样的，这个题我们会使用到 `001` 和 `00C` 两个颜色，并且，我们可以注意到：
>
> 假设横坐标和纵坐标分别为 i 和 j，整个图形可以看做是 `0 <= i < 4 && 0 <= j < 4` 这个图形的递归输出，那么 `board[i][j]` 的颜色为:
>
> - `i % 4 <= 1` && `j % 4 <= 1`，则颜色是 `001`；
> - `i % 4 >= 2` && `j % 4 <= 1`，则颜色是 `00C`；
> - `i % 4 <= 1` && `j % 4 >= 2`，则颜色是 `001`；
> - `i % 4 >= 1` && `j % 4 <= 1`，则颜色是 `00C`；
>
> 也就是说，我们可以使用一个 `4 * 4` 的二维数组来计算当前像素点的颜色并着色。
>
> 此外，如果我们把每个同颜色 `2 * 2` 色块作为一个整体来看，那么每次当我们来到左上的顶点时，我们可以将改区域的全部节点上色，也就是：
>
> - PIX x color
> - PIX (x + 1) color
> - PIX (x + 10) color
> - PIX (x + 11) color
>
> 更进一步，在这种情况下，我们可以利用我们在 CHECKBOARD 中使用到的 `FLP` 指令来对颜色进行翻转，可以直接省略掉这个 4 * 4 的二维数组 

#### Code

```assembly
MOV 001 @80 000 // @80 = current color
MOV 00C @81 000 // @81 = next color
MOV 000 @82 000 // @82 = loop count
MOV 000 @83 000 // @83 = pixel index

PIX @83 @80 000 // 画该区域内的四个色块
ADD @83 001 @83
PIX @83 @80 000
ADD @83 010 @83
PIX @83 @80 000
ADD @83 -01 @83
PIX @83 @80 000
ADD @83 -0E @83 // 跳转到下一个色块
ADD @82 001 @82	// loop + 1

JGR @82 007 00C // 跳转#1

FLP @80 @81 000
JMP -2C 000 000

MOD @82 008 @82 // #1 重置loop count
ADD @83 010 @83 // 移动 pixel index
JMP -38 000 000
```

#### Result

![CHECKBOARD-II](/images/20250319/CHECKBOARD-II.png)

### FOUR SQUARES

> 这题用到了四种不同的颜色：`008`, `009`, `00A`, `00B`，所以我们可以预先定义一个变量表示当前颜色，在每次循环结束时递增颜色，整个执行过程可以描述为：
>
> 1. 初始化参数：
>    1. 初始化 pixel index 为 `0`；
>    2. 初始化 direction index 为 `0`，控制 pixel index 移动方向；
>    3. 初始化 color 到 `008`；
> 2. 画上面的横边，画完后修改索引控制 pixel index 向下移动；
> 3. 画右边的竖边，画完后修改索引控制 pixel index 向左移动；
> 4. 画下面的横边，画完后修改索引控制 pixel index 向上移动；
> 5. 准备画下一个正方形：
>    1. 移动 pixel index 到下一个正方形的起始点；
>    2. Reset direction index；
>    3. color++；

#### Code

```assembly
MOV 000 @80 000 // @80 pixel index
MOV 000 @81 000 // @81 loop count of drawing verticals of square
MOV 000 @82 000 // @82 loop count of drawing dots of vertical
MOV 008 @83 000 // @83 current color
MOV 085 @84 000 // @84 direction index
MOV 001 @85 000 // @85 move cursor right
MOV 010 @86 000 // @86 move cursor down
MOV -01 @87 000 // @87 move cursor left
MOV -10 @88 000 // @88 move cursor up

PIX @80 @83 000 // pixel a point
ADD @82 001 @82
ADD @80 *84 @80
JGR 003 @82 -0C // jump if done drawing a vertical
ADD @81 001 @81
JGR @81 003 010 // jump if done drawing a square
ADD @84 001 @84
MOV 000 @82 000
JMP -20 000 000 // jump to draw next vertical

// reset all propertries for drawing the next square
ADD @80 044 @80
MOV 000 @81 000
MOV 000 @82 000
ADD @83 001 @83
MOV 085 @84 000
JMP -48 000 000
```

#### Result

![FOUR-SQUARE](/images/20250319/FOURE-SQUARES.png)
