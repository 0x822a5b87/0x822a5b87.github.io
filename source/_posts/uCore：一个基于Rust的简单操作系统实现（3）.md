---
title: uCore：一个基于Rust的简单操作系统实现（3）
date: 2025-11-18 18:12:28
tags:
    - rust
    - os
---

# 多道程序与分时多任务

## QA

### `__switch` 函数的实现

### 为什么 `__switch` 只需要保存 `sp`, `ra`, `s0`~`s11` 寄存器？

我看了一下部分操作系统的实现，大概的理解是，从函数调用的角度，寄存器被分为两个大类型：

1. caller-saved 由调用者保存，也就是 a0~a7 等，函数在调用时会将这些数据保存到自己的函数栈，后续访问都通过函数栈上保存的值来访问；
2. callee-saved 由被调用者保存，也就是 ra, fp, s0~s11 等，被调用的函数需要保存原始值，并且在函数退出之后将这些寄存器恢复到原值。


此外，在操作系统中，定义了两个不同的函数来保存上下文：

1. __alltraps 用于在trap发生时用来处理中断，此时会保存所有的寄存器作为上下文；
2. __switch 用于在需要发生上下文切换时来处理中断，此时只会保存 callee-saved；

为什么 __switch 只需要保存 callee-saved？而 __alltraps 需要保存全部的寄存器？

这是因为，__alltraps 是在发生trap时，由CPU来触发跳转的，所以他是不可控的在任意时间段都有可能发生。

而 __switch 则是一个普通的函数，他是在代码中由内核来进行调度的，他是可控的。

在我们前面提到的例子中：

>线程一

```asm
foo:
	addi sp, sp, -16
	sd   a0, 0(sp)
```

>线程二

```asm
bar:
	li a0, 0x0
```

可能会出现如下的执行顺序：

1. addi sp, sp -16
2. `__alltraps`
3. li a0, 0x0
4. `__restore`
5. sd a0, 0(sp)

在这个例子中，